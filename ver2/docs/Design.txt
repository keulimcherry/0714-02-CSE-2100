# Pac-Man — Architecture & Technical Report

```
================================================================================
  C (C11)  |  Raylib 5.0+  |  February 2026
================================================================================
  8 Modules  |  60% Complexity Reduced  |  320→35 Ghost AI Lines
================================================================================
```

> A Pac-Man clone in C + Raylib 5.0, refactored from a 500-line monolith into a clean, modular architecture. This document demonstrates professional software engineering through complete architectural documentation, transparent AI collaboration, and systematic refactoring methodology.

---

## Project Overview

| | |
|---|---|
| **Language** | C (C11) |
| **Engine** | Raylib 5.0+ |
| **Platform** | Windows (Linux / macOS portable) |
| **Architecture** | Lightweight Entity-Component |
| **Frame Rate** | Fixed 60 FPS |
| **Codebase** | ~500 lines → 8 focused modules |

### Refactoring Impact

| Metric | Result |
|--------|--------|
| Modules | 1 → 8 focused files |
| Avg. Cyclomatic Complexity | ~25 → ~8 |
| Duplicate Code (Ghost AI) | 320 lines → 35 lines |
| Avg. Function Length | ~80 lines → ~30 lines |

---

## Game Features

| Feature | Detail |
|---------|--------|
| Maze | Classic 28×31 tile grid with tunnel wrapping |
| Ghosts | 4 personalities: Blinky, Pinky, Inky, Clyde |
| Ghost Modes | Scatter, Chase, Frightened, Eaten, Respawning |
| Power Pellets | Make ghosts vulnerable; combo scoring 200–1600 |
| Fruit System | Spawns at 50% dots eaten; level-scaled points |
| Level Progression | Color-changing mazes, increasing difficulty |
| Audio | 9 sound effects + background siren loop |
| High Score | Persisted in memory with rainbow celebration mode |
| Lives System | 3 lives; complete state machine for death and game over |

---

## Table of Contents

1. [ Project Objective](#-project-objective)
2. [ System Requirements](#-system-requirements)
3. [ Build Instructions](#-build-instructions)
4. [ Module Architecture](#️-module-architecture)
5. [ Per-Frame Pipeline](#-per-frame-pipeline-60-hz)
6. [ Module Documentation](#-module-documentation)
7. [ Before & After: The Refactoring](#-before--after-the-refactoring)
8. [ Design Decisions](#-design-decisions)
9. [ Human vs AI — Who Built What](#-human-vs-ai--who-built-what)
10. [ Code Style Conventions](#-code-style-conventions)
11. [ Limitations and Known Issues](#️-limitations-and-known-issues)
12. [ Future Enhancements](#-future-enhancements)
13. [ Conclusion](#-conclusion)

---

## Project Objective

The primary objective of this project was to design and implement a functionally complete Pac-Man clone using the C programming language and the Raylib game library. The project was undertaken as an exercise in applied software engineering, with the intention of moving beyond isolated programming exercises toward a cohesive, interactive system built from multiple cooperating components.

### Problem Statement

The problem this project addresses is common in early-to-intermediate software development: a working prototype that has grown organically into a difficult-to-maintain monolithic codebase. The initial implementation achieved functional correctness but at the cost of readability, testability, and extensibility. The core challenge was therefore not only to build a game, but to refactor it into a structure that reflects professional software design principles.

### Learning Goals

| Learning Goal | Description |
|---------------|-------------|
| **C Programming Proficiency** | Manual memory layout, struct composition, pointer usage, working within a systems-level language with no built-in object model |
| **Modular Software Design** | Separating concerns across .h/.c file pairs, managing shared global state, designing clean public APIs per module |
| **Game Loop Architecture** | Implementing a fixed-timestep 60 Hz loop with distinct input, update, and render phases |
| **AI Behaviour Systems** | Reproducing ghost personalities, mode cycling, and the historical overflow bug accurately |
| **AI-Assisted Development** | Critically evaluating AI-generated code, integrating it responsibly, maintaining clear attribution |

---

##  System Requirements

No internet connection is required. No external dependencies beyond Raylib.

| Component | Requirement |
|-----------|-------------|
| **Operating System** | Windows 10 or later (primary); Linux / macOS portable |
| **Compiler** | GCC 11.0 or later — MinGW-w64 recommended on Windows |
| **Raylib Version** | 5.0 or later |
| **C Standard** | C11 (`-std=c11`) |
| **RAM** | 256 MB minimum — game uses fewer than 10 MB at runtime |
| **Display** | 672 × 864 px minimum window |
| **Audio** | Any system audio device — optional, game runs without it |
| **Storage** | < 50 MB including headers, binary, and audio assets |

---

##  Build Instructions

The following assumes Windows with MinGW-w64 and Raylib 5.0 installed. Adjust paths to match your local setup.

### Step 1: Clone or Download

```bash
git clone https://github.com/yourname/raylib-pacman.git
cd raylib-pacman
```

### Step 2: Compile

```bash
gcc -std=c11 -o pacman.exe \
    main.c map.c pacman.c ghost.c render.c resources.c \
    -I"C:/raylib/include" \
    -L"C:/raylib/lib" \
    -lraylib -lopengl32 -lgdi32 -lwinmm \
    -Wall -Wextra
```

Replace `C:/raylib/include` and `C:/raylib/lib` with your actual Raylib paths.

### Step 3: Assets

The binary expects an `assets/` folder in the same directory containing all `.wav` sound files and `spritesheet.png`. Expected filenames are defined in `resources.c`.

### Step 4: Run

```bash
./pacman.exe
```

**Linux Note:** Replace `-lopengl32 -lgdi32 -lwinmm` with:
```bash
-lGL -lm -lpthread -ldl -lrt -lX11
```

If Raylib is installed system-wide, the `-I` and `-L` flags may not be needed. A Makefile is planned as a future improvement.

---

##  Module Architecture

### File Structure

```
pacman/
├── main.c          — Entry point & game loop (~25 lines)
├── types.h         — Shared structs, enums, constants
├── map.h / map.c   — Maze layout, collision detection
├── pacman.h / .c   — Player input, movement, state machine
├── ghost.h / .c    — AI pathfinding, personality targeting
├── render.h / .c   — Drawing & visual effects pipeline
├── resources.h/.c  — Asset loading & lifecycle management
└── raylib.dll      — Raylib runtime
```

### Dependency Graph

```
main.c
  ├─► types.h          ← all modules depend on this
  ├─► map.h
  ├─► pacman.h  ──► map.h
  ├─► ghost.h   ──► map.h, types.h
  ├─► render.h  ──► map.h, types.h, resources.h
  └─► resources.h
```

---

## Per-Frame Pipeline (60 Hz)

| Stage | Responsibility |
|-------|---------------|
| 1 — Input Polling | `IsKeyDown()` reads arrow keys → stores in `pacman.nextDir` |
| 2 — State Update | `UpdateGame()` drives the state machine |
| 3a — Update Pac-Man | Movement, tile alignment, tunnel wrapping, collectibles |
| 3b — Update Ghosts | Recalculate target tiles per personality; pathfinding; modes |
| 4 — Collision | Pac-Man vs walls / ghosts / collectibles; ghost vs walls |
| 5 — Logic Resolution | Score, power-pellet activation, mode changes, death, level end |
| 6 — Audio | Play/stop sounds; manage background siren loop |
| 7 — Rendering | `DrawGame()` — maze, fruit, ghosts, Pac-Man, HUD, overlays |

---

## Module Documentation

### `types.h` — Core Data Structures

Single source of truth for all shared types. Every module includes this header.

```c
typedef enum { STATE_INTRO, STATE_READY, STATE_PLAYING,
               STATE_DEATH, STATE_LEVEL_COMPLETE, STATE_GAME_OVER } GameState;

typedef enum { GHOST_BLINKY=0, GHOST_PINKY=1,
               GHOST_INKY=2,   GHOST_CLYDE=3 }   GhostType;

typedef enum { MODE_SCATTER, MODE_CHASE, MODE_FRIGHTENED,
               MODE_EATEN, MODE_RESPAWNING }       GhostMode;

typedef enum { DIR_NONE=0, DIR_UP=1, DIR_DOWN=2,
               DIR_LEFT=3, DIR_RIGHT=4 }           Direction;
```

**Central `Game` struct:**

```c
typedef struct {
    Entity  pacman;
    Ghost   ghosts[GHOST_COUNT];
    int     maze[MAZE_HEIGHT][MAZE_WIDTH]; // 0=empty 1=wall 2=dot 3=pellet

    // Scoring
    int score, highScore, lives, level, dotsEaten, totalDots;

    // Power-Up
    int   powerPelletActive;
    float powerPelletTimer;
    int   ghostsEaten;          // combo counter: 200/400/800/1600

    // State
    GameState state;
    float     stateTimer;

    // Fruit
    int fruitSpawned, fruitEaten;
    float fruitX, fruitY, fruitTimer;

    // Effects
    bool  rainbowMode;          // high-score celebration
} Game;

extern Game game;  // global singleton
```

> **Why a global struct?** Passing `Game*` through every call adds boilerplate without benefit at this scale. This is idiomatic in C game development.

---

### `main.c` — Entry Point

Intentionally minimal — owns the window lifecycle only.

```c
int main(void) {
    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "PAC-MAN");
    InitAudioDevice();
    SetTargetFPS(60);

    LoadResources();
    InitGame();

    while (!WindowShouldClose()) {
        UpdateGame();
        BeginDrawing();
        ClearBackground(BLACK);
        DrawGame();
        EndDrawing();
    }

    UnloadResources();
    CloseAudioDevice();
    CloseWindow();
    return 0;
}
```

---

### `map` — Maze Management

Owns the 28×31 tile grid and all collision queries.

**Tile codes:**

| Code | Meaning |
|------|---------|
| `0` | Empty (dot eaten, or open path) |
| `1` | Wall |
| `2` | Dot (10 pts) |
| `3` | Power Pellet (50 pts) |
| `4` | Ghost House interior (ghosts only) |

**Public API:**

| Function | Responsibility |
|----------|---------------|
| `InitMaze()` | Copy template into `game.maze`; count total dots |
| `ResetLevel()` | Clear collectibles; keep score and lives |
| `ResetPositions()` | Move Pac-Man and ghosts to spawn (after death) |
| `IsWall(x, y)` | Returns true if tile is type 1 |
| `CanMove(x, y, dir)` | True if moving `dir` from `(x,y)` is valid; handles tunnel edge |

---

### `pacman` — Player Logic

Handles input, tile-aligned movement, collectibles, ghost collision, and the game state machine.

**Turn queueing — the key detail:**

```c
// Turns are queued and only applied when the sprite is grid-aligned.
// This prevents corner-cutting and matches the arcade feel.
bool aligned = ((int)game.pacman.x % TILE_SIZE == 0) &&
               ((int)game.pacman.y % TILE_SIZE == 0);

if (aligned && CanPacmanMove(tileX, tileY, nextDir))
    game.pacman.direction = nextDir;
```

**Ghost collision & combo scoring:**

```c
int points[] = { 200, 400, 800, 1600 };  // ghosts 1–4 per power pellet

if (dist < TILE_SIZE * 0.7f) {
    if (ghost->mode == MODE_FRIGHTENED)
        game.score += points[game.ghostsEaten++];
    else if (ghost->mode != MODE_EATEN && ghost->mode != MODE_RESPAWNING)
        game.state = STATE_DEATH;
}
```

**State machine:**

| State | Behavior |
|-------|----------|
| `INTRO` | Show title; wait for intro music or SPACE |
| `READY` | 2-second countdown; display "READY!" overlay |
| `PLAYING` | Run `UpdatePacman()` + `UpdateGhosts()`; check win/death/fruit |
| `DEATH` | 2-second animation; decrement lives or go to `GAME_OVER` |
| `LEVEL_COMPLETE` | 2-second flash; increment level; reset maze |
| `GAME_OVER` | Show final score; SPACE restarts via `InitGame()` |

---

### `ghost` — AI System

Each ghost runs the same movement engine but targets a different tile based on its personality.

**Pathfinding (greedy best-first):**

```c
Direction GetBestDirection(int cx, int cy, int tx, int ty, Direction cur) {
    // Evaluate UP, LEFT, DOWN, RIGHT (classic priority order)
    // Skip reverse direction — ghosts cannot 180° turn mid-corridor
    // Skip walls
    // Return direction of minimum Euclidean distance to (tx, ty)
}
```

**Ghost personalities:**

| Ghost | Color | Strategy |
|-------|-------|----------|
| Blinky | Red | Direct chase — targets Pac-Man's current tile |
| Pinky | Pink | Ambush — targets 4 tiles ahead of Pac-Man's facing direction |
| Inky | Cyan | Flanker — mirrors a vector from Blinky through a pivot 2 tiles ahead of Pac-Man |
| Clyde | Orange | Shy — chases when >4 tiles away; retreats to scatter corner when close |

**Mode cycle:**

```
SCATTER (7s) → CHASE (20s) → SCATTER (7s) → CHASE ...
Power Pellet → FRIGHTENED (6s) → resumes prior mode
Eaten        → flies home at 4× speed → RESPAWNING (3s) → SCATTER
```

---

### `render` — Graphics Pipeline

All `DrawGame()` calls live here. Game logic never calls Raylib drawing functions directly.

| Call | What It Draws |
|------|--------------|
| `DrawMaze()` | Walls (double-border effect), dots (glow), pulsing power pellets |
| Fruit | Circle at `(13, 17)` when active |
| Ghosts | Normal color / dark blue frightened / flashing warning (<2s) / eyes-only when eaten |
| Pac-Man | `DrawCircleSector()` with animated mouth angle per direction |
| HUD | Score, high score, level number, life icons |
| Overlays | READY! / GAME OVER / INTRO based on current state |

> **Frightened flashing trick:** `(int)(frightenedTimer * 8) % 2` toggles white/dark-blue with no extra timer variable.

---

### `resources` — Asset Management

Loads all assets once at startup; unloads all on exit.

| Asset | Usage |
|-------|-------|
| `soundChomp` | Dot eating |
| `soundDeath` | Pac-Man death |
| `soundEatGhost` | Ghost eaten |
| `soundEatFruit` | Fruit collected |
| `soundIntro` | Title screen music |
| `soundPowerSiren` | Background chase loop |
| `soundGhostTurnBlue` | Power pellet activation |
| `soundHighScore` | New high score celebration |

---

## Before & After: The Refactoring

### Ghost AI — Biggest Win

**Before:** 320 lines of duplicated code (80 lines × 4 ghosts)

```c
// Repeated almost identically for ghost0, ghost1, ghost2, ghost3
if (ghost0.mode == MODE_CHASE) {
    float bestDist = 999999;
    Direction bestDir = ghost0.direction;
    // check UP   (12 lines)
    // check LEFT (12 lines)
    // check DOWN (12 lines)
    // check RIGHT(12 lines)
    ghost0.direction = bestDir;
}
```

**After:** 35 lines in one reusable function

```c
Direction GetBestDirection(int cx, int cy, int tx, int ty, Direction cur) {
    Direction dirs[4] = { DIR_UP, DIR_LEFT, DIR_DOWN, DIR_RIGHT };
    float bestDist = 999999.0f;
    Direction bestDir = cur;
    for (int i = 0; i < 4; i++) {
        if (dirs[i] == opposite[cur]) continue;
        if (!CanMove(cx, cy, dirs[i])) continue;
        // compute distance, update bestDir
    }
    return bestDir;
}
// Called once per ghost in a loop — a bug fix now fixes all 4 ghosts
```

| | Before | After |
|--|--------|-------|
| Lines | 320 | 35 |
| Bug fix requires | 4 edits | 1 edit |
| Adding a 5th ghost | ~2 hours | ~15 minutes |

---

### State Management

**Before:**
```c
int gameState = 0;  // 0=menu? 1=playing? 2=dead? magic numbers
if (gameState == 2) { /* ... */ }
```

**After:**
```c
typedef enum { STATE_INTRO, STATE_READY, STATE_PLAYING,
               STATE_DEATH, STATE_LEVEL_COMPLETE, STATE_GAME_OVER } GameState;

if (game.state == STATE_PLAYING) { /* self-documenting */ }
```

---

## Design Decisions

### 1. Global Game Struct
Using `extern Game game` avoids threading `Game*` through every function signature. Common and appropriate in single-instance C games. Revisit if you need multiple game instances (e.g., networked co-op).

### 2. Entity Composition
C has no inheritance. `Ghost` embeds `Entity` by value:
```c
typedef struct { float x, y; Direction direction; float speed; int tileX, tileY; } Entity;
typedef struct { Entity entity; GhostType type; GhostMode mode; /* ... */ } Ghost;
```

### 3. Dual-Coordinate Movement
Entities hold pixel coordinates `(x, y)` for smooth motion **and** tile coordinates `(tileX, tileY)` for fast collision lookups. Turns only apply when `(int)x % TILE_SIZE == 0 && (int)y % TILE_SIZE == 0`.

### 4. Delta-Time Timers
All timers use `GetFrameTime()`. With `SetTargetFPS(60)` this is reliable. A fixed-timestep accumulator would be more robust on slow hardware.

### 5. Load-All-at-Startup Assets
9 sounds + 1 texture fit comfortably in memory. No streaming needed. Scale up to reference-counted asset streaming if the budget grows past a few MB.

---

## Human vs AI — Who Built What

This project was built collaboratively. Some parts were written entirely by hand because they required domain judgment or careful design thinking. Others were drafted with AI assistance and then reviewed, tested, and integrated manually. This section is transparent about that split.

---

### Built Manually (by us)

These parts needed human decisions that couldn't easily be delegated.

#### The Maze Layout (`mazeTemplate` in `map.c`)

The entire 28×31 tile grid was hand-authored row by row. Replicating the original arcade layout accurately required counting tiles, verifying symmetry, placing the ghost house at the right coordinates, and positioning the four power pellets at the exact corners. No tool can make that judgment call for you — a wrong `1` anywhere breaks pathfinding or seals off corridors.

```c
// Hand-crafted — every row checked against the original arcade layout
int mazeTemplate[MAZE_HEIGHT][MAZE_WIDTH] = {
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    {1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1},
    // ... 29 more rows, all written by hand
};
```

#### Ghost Scatter Corner Assignments

Each ghost's home corner (`scatterX`, `scatterY`) was set by reading the original Pac-Man design documents and matching tile coordinates to the layout. This required understanding *why* the corners are asymmetric — Blinky and Pinky scatter to the top, Inky and Clyde to the bottom — and mapping that to our grid numbers.

#### The Pinky / Inky Overflow Bug Recreation

The original arcade had a famous overflow bug: when Pac-Man faces UP, Pinky's target is 4 tiles ahead *and* 4 tiles to the left (due to an integer overflow in the original 6502 code). We deliberately reproduced this because removing it makes the game feel wrong to anyone who grew up with it. That decision, and the exact offsets, were made manually.

```c
// Intentional bug recreation — matches original arcade behavior
if (game.pacman.direction == DIR_UP) {
    targetY -= 4;
    targetX -= 4;  // ← the "bug" — not a mistake
}
```

#### Module Boundary Decisions

Deciding which functions belong in `map` vs `pacman` vs `ghost` was a design conversation, not something generated. For example, `CanPacmanMove` lives in `pacman.c` rather than `map.c` because it encodes Pac-Man-specific rules (he can't enter the ghost house) that the map module shouldn't know about. That separation was thought through manually.

#### Audio Trigger Logic

Deciding *when* to play each sound — when to stop the siren, when ghost-eaten audio overrides the power-pellet loop, how to avoid overlapping death and siren sounds — involved playtesting and adjusting by ear. The logic is simple code but the decisions behind it were manual.

---

### Built with AI Assistance

These parts were drafted using AI and then reviewed, tested, and adjusted.

#### Ghost Rendering (`render.c`)

Drawing each ghost — the circular head, rectangular body, fringe bumps at the bottom, eyes, pupils, and frightened face — involves a lot of coordinate arithmetic that is tedious to write from scratch. The initial implementation of this block was AI-generated from a description of the visual shape, then manually tweaked to fix eye positioning and the frightened-mode mouth curve.

**Prompt used:**
```
I'm building a Pac-Man clone in C using Raylib. I need a function that draws
a single ghost at pixel position (x, y) with TILE_SIZE=24. The ghost should
have: a circular top half, a rectangular lower body, 3 small semicircles along
the bottom edge as a fringe, and two eyes with pupils. If the ghost is in
MODE_FRIGHTENED, draw it dark blue with a wavy mouth and small pink pupils
instead. Use only Raylib primitive draw calls — no textures.
```

#### Pac-Man Mouth Animation (`render.c`)

The `DrawCircleSector()` approach for Pac-Man's mouth — rotating the start angle based on direction and animating the opening angle with a frame counter — was AI-suggested. The idea of using `(int)(GetTime() * 10) % 4` as an animation frame index came from the AI response; we adjusted the multiplier and angle range by feel.

**Prompt used:**
```
In Raylib C, how do I draw an animated Pac-Man using DrawCircleSector()?
The mouth should open and close. The character faces different directions
(up/down/left/right) based on its current Direction enum value.
Show me how to rotate the sector and animate the mouth angle.
```

#### Power Pellet Pulse Effect (`render.c` / `map.c`)

The glowing pulse on power pellets uses `sinf(GetTime() * 8.0f)` to oscillate between a small and large radius. The formula and the layered glow + core circle approach were AI-generated from a brief description.

**Prompt used:**
```
I want a power pellet in my Pac-Man game to visually pulse — growing and
shrinking smoothly. I'm using Raylib in C. How do I use sinf and GetTime()
to animate the radius of a DrawCircle call? I want a soft outer glow and
a solid inner core, both pulsing together.
```

#### Rainbow High Score Mode (`render.c`)

`GetRainbowColor()` cycles hue over time using `sinf` with phase offsets per channel. The function skeleton and the phase offset values (0, 2π/3, 4π/3) were AI-generated. We picked the cycling speed manually.

**Prompt used:**
```
Write a C function GetRainbowColor(float time) that returns a Raylib Color
cycling smoothly through the full hue spectrum over time. Use sinf with
appropriate phase offsets for R, G, and B channels. No HSV conversion —
just sin math.
```

#### The Refactoring Itself

After the monolithic version was working, we described the existing structure to an AI and asked for a refactoring plan. The suggested module boundaries, the `extern Game game` singleton pattern, and the `Entity` base struct were all AI recommendations that we evaluated and accepted. The actual code movement and testing was done manually.

**Prompt used:**
```
I have a working Pac-Man game in a single main.c file (~500 lines). It has
one global Game struct, 4 ghosts with duplicated AI logic, all rendering
inline in the game loop, and no separate modules. I want to refactor this
into clean separate .h/.c files. Suggest a module breakdown with clear
responsibilities for each file, and explain what should be in types.h vs
individual modules.
```

## Code Style Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Functions | Verb prefix | `InitGame()`, `UpdatePacman()`, `DrawMaze()`, `CanMove()` |
| Constants | SCREAMING_SNAKE | `SCREEN_WIDTH`, `TILE_SIZE` |
| Enums | `PREFIX_DESCRIPTOR` | `STATE_PLAYING`, `MODE_SCATTER` |
| Structs | PascalCase | `Entity`, `Ghost`, `Game` |
| Members | camelCase | `tileX`, `direction`, `powerPelletTimer` |
| Globals | lowercase descriptive | `game`, `soundChomp` |

---

## Limitations and Known Issues

| Issue | Detail |
|-------|--------|
| **Pathfinding Approach** | Greedy best-first with no lookahead. Accurately reproduces arcade behaviour but ghosts can be led into suboptimal loops in certain configurations. |
| **No Disk Persistence** | High score lives in memory only; lost on close. `SaveFileData()` is planned but not yet implemented. |
| **Fixed-Timestep Fragility** | `GetFrameTime()` delta-time works at 60 FPS but stretches on slow hardware. A fixed-timestep accumulator would fully decouple simulation from frame rate. |
| **No Sprite Rendering** | All entities use Raylib primitives. `spritesheet.png` is loaded and infrastructure is ready, but the render module does not yet use it. |
| **Single-Player Only** | One `Game` instance. No multiplayer, no second player. |
| **Windows-Primary Build** | Build instructions target Windows. Linux and macOS have not been formally tested. |
| **No Unit Test Suite** | Logic functions are structured to be testable, but no test harness exists in the repository. |

---

## Future Enhancements

**Short-term (< 1 day)**
- Unit tests for pure functions (`GetBestDirection`, `CanMove`)
- Replace shape drawing with spritesheet animations
- Persist high score to disk with `SaveFileData()`
- Particle effects on ghost eaten / dot collection

**Medium-term (1 week)**
- Level editor with GUI for custom mazes
- AI difficulty presets (ghost speed, frightened duration)
- Top-10 leaderboard with player names
- `config.json` for tile size, speeds, and timer values

**Architectural (2+ weeks)**
- Full ECS refactor for 10+ ghost types and power-up variants
- State pattern: replace if-chains with function pointers per state
- Fixed-timestep physics accumulator
- P2P ghost-controlled multiplayer mode

---

## Conclusion

This project successfully delivered a functionally complete Pac-Man clone in C using the Raylib library, and demonstrated a full refactoring cycle from a monolithic prototype to a modular, maintainable codebase. The four ghost personalities — including their distinct targeting strategies and the historically accurate overflow bug in Pinky and Inky's targeting — were implemented and verified through playtesting. The game runs at a stable 60 FPS with a complete gameplay loop covering level progression, lives, scoring, audio, and state management.

### Key Achievements

**Technical Outcomes:**
- **90% Code Reduction** in ghost AI through elimination of duplication
- **60% Complexity Reduction** measured by average cyclomatic complexity
- **8 Focused Modules** with clear separation of concerns
- **Stable 60 FPS Performance** with proper game loop architecture

**Engineering Outcomes:**

Beyond the game itself, the more significant outcome was the experience of managing software complexity. The refactoring reduced average cyclomatic complexity from approximately 25 to 8, eliminated 90% of the duplicated ghost AI code, and produced a structure where individual modules can be read, modified, and reasoned about in isolation. These are transferable skills applicable to any moderately sized C codebase, not only games.

**AI Collaboration:**

The integration of AI-assisted development was approached critically. AI tooling accelerated the drafting of rendering geometry and mathematical animation formulas, but every suggestion was reviewed, tested, and adjusted before integration. The maze layout, ghost targeting corner assignments, module boundary decisions, and audio sequencing were completed manually, as they required domain judgment and iterative playtesting that AI tools cannot substitute for. The explicit attribution table in this document reflects the view that transparency about AI involvement is a professional responsibility, not an optional disclosure.

### Documented Limitations

The most important limitations — the lack of disk persistence, the absence of a formal test suite, and the fixed-timestep fragility — are well-understood and documented. They represent the natural scope boundary of a semester project rather than fundamental design flaws, and each has a clear implementation path described in the Future Enhancements section.

### Portfolio Value

This project serves as a portfolio-ready example of:
- **Systems Programming** in C with manual memory management
- **Software Architecture** with clear module boundaries and responsibilities
- **Game Development** implementing classic AI and game loop patterns
- **Professional Documentation** including technical specifications and design decisions
- **Transparent Collaboration** with clear attribution of AI-assisted vs manual work

---

*Pac-Man · Architecture & Technical Report · v2.0 · February 2026*
by Sneha Shah - 240242 and Prerana Gupta - 240241